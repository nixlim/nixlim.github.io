<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects on Foundry of Zero</title><link>https://foundryofzero.ai/projects/</link><description>Recent content in Projects on Foundry of Zero</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://foundryofzero.ai/projects/index.xml" rel="self" type="application/rss+xml"/><item><title>Hive</title><link>https://foundryofzero.ai/projects/hive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://foundryofzero.ai/projects/hive/</guid><description>&lt;p&gt;The premise is absurd and therefore worth trying: take multiple Claude Code agents, give them distinct roles &amp;ndash; architect, engineer, reviewer &amp;ndash; and make them collaborate on real software tasks like a dysfunctional but surprisingly productive team.&lt;/p&gt;
&lt;p&gt;Hive throws out the assumption that AI coding means one agent, one task, one context window. Instead, there&amp;rsquo;s a supervisor process that breaks objectives into pieces, assigns them to a pool of agents, and lets each one work in its own isolated git worktree. Nobody steps on anyone&amp;rsquo;s toes. Nobody shares a context window. They just&amp;hellip; build things in parallel, and somehow it works.&lt;/p&gt;</description></item><item><title>Academic Quote Extractor</title><link>https://foundryofzero.ai/projects/academic-quote-extractor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://foundryofzero.ai/projects/academic-quote-extractor/</guid><description>&lt;p&gt;Here&amp;rsquo;s a thing that shouldn&amp;rsquo;t need to exist but does: a CLI that reads your academic papers, finds the quotes you actually need, and spits out properly formatted Harvard citations. You ask a research question, it gives you real quotes with real page numbers from real sources. No hallucinated references. No fabricated citations. No &amp;ldquo;this paper by et al. (2024) that definitely doesn&amp;rsquo;t exist.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;The zero-hallucination guarantee is the whole point. The LLM never generates or paraphrases quotes &amp;ndash; it only scores relevance of passages that were already retrieved verbatim from SQLite. Every single citation traces back to exact source text. This exists because the most dangerous thing an LLM can do in academia is make up a reference that sounds plausible, and someone decided that was a solvable problem rather than an acceptable risk.&lt;/p&gt;</description></item><item><title>OpenCode Beads Plugin</title><link>https://foundryofzero.ai/projects/opencode-beads-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://foundryofzero.ai/projects/opencode-beads-plugin/</guid><description>&lt;p&gt;The problem is dumb and the solution is elegant: AI coding agents have no memory of your project&amp;rsquo;s issues, tasks, or priorities unless you manually paste them in every single time. That&amp;rsquo;s the kind of tedious, repetitive work that computers were literally invented to eliminate. So this plugin eliminates it.&lt;/p&gt;
&lt;p&gt;It hooks into three moments of an OpenCode session. When a session starts, it runs &lt;code&gt;bd prime&lt;/code&gt; and injects the full project context &amp;ndash; open issues, priorities, workflow conventions &amp;ndash; straight into the agent&amp;rsquo;s prompt. When context gets compacted, it re-injects so nothing gets lost. When the session goes idle, it syncs issue state back to git. The agent just &lt;em&gt;knows&lt;/em&gt; what needs doing without you having to explain it again.&lt;/p&gt;</description></item><item><title>Task Templating</title><link>https://foundryofzero.ai/projects/task-templating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://foundryofzero.ai/projects/task-templating/</guid><description>&lt;p&gt;Tell an AI agent to &amp;ldquo;build the thing&amp;rdquo; and it will happily build &lt;em&gt;a&lt;/em&gt; thing. Whether it&amp;rsquo;s &lt;em&gt;your&lt;/em&gt; thing depends entirely on how many assumptions it made to fill the gaps in your vague description. The answer is usually &amp;ldquo;too many.&amp;rdquo; Task Templating exists because someone got tired of the rework loop and decided to make ambiguity structurally impossible.&lt;/p&gt;
&lt;p&gt;The format forces completeness. Every task needs a &lt;code&gt;TASK_ID&lt;/code&gt;, &lt;code&gt;TASK_NAME&lt;/code&gt;, &lt;code&gt;GOAL&lt;/code&gt;, &lt;code&gt;INPUTS&lt;/code&gt;, &lt;code&gt;OUTPUTS&lt;/code&gt;, and &lt;code&gt;ACCEPTANCE&lt;/code&gt; criteria. No optional hand-waving. You also specify &lt;code&gt;DEPENDS_ON&lt;/code&gt;, &lt;code&gt;CONSTRAINTS&lt;/code&gt;, and &lt;code&gt;FILES_SCOPE&lt;/code&gt; because context matters and &amp;ldquo;just figure it out&amp;rdquo; is not architecture. If a field is empty, the task isn&amp;rsquo;t ready, and the validator will tell you so in terms that leave no room for negotiation.&lt;/p&gt;</description></item></channel></rss>